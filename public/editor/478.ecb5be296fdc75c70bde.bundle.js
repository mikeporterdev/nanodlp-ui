"use strict";(self.webpackChunknanosupport=self.webpackChunknanosupport||[]).push([[478],{1478:(t,e,r)=>{r.r(e),r.d(e,{LDrawLoader:()=>w});var a=r(7749);const n="16",o="24",i=new a.Vector3,s=new a.Vector3;class l extends a.ShaderMaterial{constructor(t){super({uniforms:a.UniformsUtils.merge([a.UniformsLib.fog,{diffuse:{value:new a.Color},opacity:{value:1}}]),vertexShader:"\n\t\t\t\tattribute vec3 control0;\n\t\t\t\tattribute vec3 control1;\n\t\t\t\tattribute vec3 direction;\n\t\t\t\tvarying float discardFlag;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <color_pars_vertex>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <color_vertex>\n\n\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\t// Transform the line segment ends and control points into camera clip space\n\t\t\t\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\t\t\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\t\t\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\t\t\t\tc0.xy /= c0.w;\n\t\t\t\t\tc1.xy /= c1.w;\n\t\t\t\t\tp0.xy /= p0.w;\n\t\t\t\t\tp1.xy /= p1.w;\n\n\t\t\t\t\t// Get the direction of the segment and an orthogonal vector\n\t\t\t\t\tvec2 dir = p1.xy - p0.xy;\n\t\t\t\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t\t\t\t// Get control point directions from the line\n\t\t\t\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\t\t\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t\t\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t\t\t\t// from the line segment then the line should not be drawn.\n\t\t\t\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\t\t\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\t\t\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\t\t\tuniform vec3 diffuse;\n\t\t\tuniform float opacity;\n\t\t\tvarying float discardFlag;\n\n\t\t\t#include <common>\n\t\t\t#include <color_pars_fragment>\n\t\t\t#include <fog_pars_fragment>\n\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t#include <clipping_planes_pars_fragment>\n\t\t\tvoid main() {\n\n\t\t\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t\t\t#include <clipping_planes_fragment>\n\t\t\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t#include <color_fragment>\n\t\t\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <encodings_fragment>\n\t\t\t\t#include <fog_fragment>\n\t\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t}\n\t\t\t"}),Object.defineProperties(this,{opacity:{get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},color:{get:function(){return this.uniforms.diffuse.value}}}),this.setValues(t),this.isLDrawConditionalLineMaterial=!0}}class c extends a.LineSegments{constructor(t,e){super(t,e),this.isConditionalLine=!0}}const h=new a.Ray;function u(t){return"Part"===t||"Unofficial_Part"===t}class d{constructor(t,e){this.line=t,this.lineLength=t.length,this.currentCharIndex=0,this.currentChar=" ",this.lineNumber=e}seekNonSpace(){for(;this.currentCharIndex<this.lineLength;){if(this.currentChar=this.line.charAt(this.currentCharIndex)," "!==this.currentChar&&"\t"!==this.currentChar)return;this.currentCharIndex++}}getToken(){const t=this.currentCharIndex++;for(;this.currentCharIndex<this.lineLength&&(this.currentChar=this.line.charAt(this.currentCharIndex)," "!==this.currentChar&&"\t"!==this.currentChar);)this.currentCharIndex++;const e=this.currentCharIndex;return this.seekNonSpace(),this.line.substring(t,e)}getVector(){return new a.Vector3(parseFloat(this.getToken()),parseFloat(this.getToken()),parseFloat(this.getToken()))}getRemainingString(){return this.line.substring(this.currentCharIndex,this.lineLength)}isAtTheEnd(){return this.currentCharIndex>=this.lineLength}setToEnd(){this.currentCharIndex=this.lineLength}getLineNumberString(){return this.lineNumber>=0?" at line "+this.lineNumber:""}}class g{constructor(t){this.loader=t,this._cache={}}cloneResult(t){const e={};return e.faces=t.faces.map((t=>({colorCode:t.colorCode,material:t.material,vertices:t.vertices.map((t=>t.clone())),normals:t.normals.map((()=>null)),faceNormal:null}))),e.conditionalSegments=t.conditionalSegments.map((t=>({colorCode:t.colorCode,material:t.material,vertices:t.vertices.map((t=>t.clone())),controlPoints:t.controlPoints.map((t=>t.clone()))}))),e.lineSegments=t.lineSegments.map((t=>({colorCode:t.colorCode,material:t.material,vertices:t.vertices.map((t=>t.clone()))}))),e.type=t.type,e.category=t.category,e.keywords=t.keywords,e.subobjects=t.subobjects,e.totalFaces=t.totalFaces,e.startingConstructionStep=t.startingConstructionStep,e.materials=t.materials,e.group=null,e}async fetchData(t){let e=!1,r=0;for(;6!==r;){let n=t;switch(r){case 0:r+=1;break;case 1:n="parts/"+n,r+=1;break;case 2:n="p/"+n,r+=1;break;case 3:n="models/"+n,r+=1;break;case 4:n=t.substring(0,t.lastIndexOf("/")+1)+n,r+=1;break;case 5:e?r=6:(n=t=t.toLowerCase(),e=!0,r=0)}const o=this.loader,i=new a.FileLoader(o.manager);i.setPath(o.partsLibraryPath),i.setRequestHeader(o.requestHeader),i.setWithCredentials(o.withCredentials);try{return await i.loadAsync(n)}catch{continue}}throw new Error('LDrawLoader: Subobject "'+t+'" could not be loaded.')}parse(t,e=null){const r=this.loader,n=[],o=[],i=[],s=[],l={},c=t=>l[t]||null;let h="Model",u=null,g=null,p=0;-1!==t.indexOf("\r\n")&&(t=t.replace(/\r\n/g,"\n"));const m=t.split("\n"),f=m.length;let C=!1,w=null,M=null,b=!1,y=!0,L=!1,v=!0,k=!1;for(let t=0;t<f;t++){const e=m[t];if(0===e.length)continue;if(C){e.startsWith("0 FILE ")?(this.setData(w,M),w=e.substring(7),M=""):M+=e+"\n";continue}const f=new d(e,t+1);if(f.seekNonSpace(),f.isAtTheEnd())continue;const x=f.getToken();let S,D,E,T,_,N,V,F,A,I,R;switch(x){case"0":const e=f.getToken();if(e)switch(e){case"!LDRAW_ORG":h=f.getToken();break;case"!COLOUR":S=r.parseColorMetaDirective(f),S?l[S.userData.code]=S:console.warn("LDrawLoader: Error parsing material"+f.getLineNumberString());break;case"!CATEGORY":u=f.getToken();break;case"!KEYWORDS":const e=f.getRemainingString().split(",");e.length>0&&(g||(g=[]),e.forEach((function(t){g.push(t.trim())})));break;case"FILE":t>0&&(C=!0,w=f.getRemainingString(),M="",b=!1,y=!0);break;case"BFC":for(;!f.isAtTheEnd();){const t=f.getToken();switch(t){case"CERTIFY":case"NOCERTIFY":b="CERTIFY"===t,y=!0;break;case"CW":case"CCW":y="CCW"===t;break;case"INVERTNEXT":L=!0;break;case"CLIP":case"NOCLIP":v="CLIP"===t;break;default:console.warn('THREE.LDrawLoader: BFC directive "'+t+'" is unknown.')}}break;case"STEP":k=!0}break;case"1":D=f.getToken(),S=c(D);const d=parseFloat(f.getToken()),m=parseFloat(f.getToken()),P=parseFloat(f.getToken()),O=parseFloat(f.getToken()),z=parseFloat(f.getToken()),W=parseFloat(f.getToken()),G=parseFloat(f.getToken()),U=parseFloat(f.getToken()),B=parseFloat(f.getToken()),j=parseFloat(f.getToken()),H=parseFloat(f.getToken()),q=parseFloat(f.getToken()),$=(new a.Matrix4).set(O,z,W,d,G,U,B,m,j,H,q,P,0,0,0,1);let Y=f.getRemainingString().trim().replace(/\\/g,"/");r.fileMap[Y]?Y=r.fileMap[Y]:Y.startsWith("s/")?Y="parts/"+Y:Y.startsWith("48/")&&(Y="p/"+Y),s.push({material:S,colorCode:D,matrix:$,fileName:Y,inverted:L,startingConstructionStep:k}),L=!1;break;case"2":D=f.getToken(),S=c(D),N=f.getVector(),V=f.getVector(),E={material:S,colorCode:D,vertices:[N,V]},o.push(E);break;case"5":D=f.getToken(),S=c(D),N=f.getVector(),V=f.getVector(),I=f.getVector(),R=f.getVector(),E={material:S,colorCode:D,vertices:[N,V],controlPoints:[I,R]},i.push(E);break;case"3":D=f.getToken(),S=c(D),T=y,_=!b||!v,!0===T?(N=f.getVector(),V=f.getVector(),F=f.getVector()):(F=f.getVector(),V=f.getVector(),N=f.getVector()),n.push({material:S,colorCode:D,faceNormal:null,vertices:[N,V,F],normals:[null,null,null]}),p++,!0===_&&(n.push({material:S,colorCode:D,faceNormal:null,vertices:[F,V,N],normals:[null,null,null]}),p++);break;case"4":D=f.getToken(),S=c(D),T=y,_=!b||!v,!0===T?(N=f.getVector(),V=f.getVector(),F=f.getVector(),A=f.getVector()):(A=f.getVector(),F=f.getVector(),V=f.getVector(),N=f.getVector()),n.push({material:S,colorCode:D,faceNormal:null,vertices:[N,V,F,A],normals:[null,null,null,null]}),p+=2,!0===_&&(n.push({material:S,colorCode:D,faceNormal:null,vertices:[A,F,V,N],normals:[null,null,null,null]}),p+=2);break;default:throw new Error('LDrawLoader: Unknown line type "'+x+'"'+f.getLineNumberString()+".")}}return C&&this.setData(w,M),{faces:n,conditionalSegments:i,lineSegments:o,type:h,category:u,keywords:g,subobjects:s,totalFaces:p,startingConstructionStep:k,materials:l,fileName:e,group:null}}getData(t,e=!0){const r=t.toLowerCase(),a=this._cache[r];return null===a||a instanceof Promise?null:e?this.cloneResult(a):a}async ensureDataLoaded(t){const e=t.toLowerCase();e in this._cache||(this._cache[e]=this.fetchData(t).then((r=>{const a=this.parse(r,t);return this._cache[e]=a,a}))),await this._cache[e]}setData(t,e){const r=t.toLowerCase();this._cache[r]=this.parse(e,t)}}function p(t,e,r,a){return(!a&&t===n||a&&t===o)&&(t=e),r[t]||null}class m{constructor(t){this.loader=t,this.parseCache=new g(t),this._cache={}}async processIntoMesh(t){const e=this.loader,r=this.parseCache,l=new Set,c=async(t,i=null)=>{const s=t.subobjects,h=[];for(let t=0,e=s.length;t<e;t++){const e=s[t],a=r.ensureDataLoaded(e.fileName).then((()=>{return t=r.getData(e.fileName,!1).type,/primitive/i.test(t)||"Subpart"===t?c(r.getData(e.fileName),e):this.loadModel(e.fileName).catch((t=>(console.warn(t),null)));var t}));h.push(a)}const u=new a.Group;u.userData.category=t.category,u.userData.keywords=t.keywords,t.group=u;const d=await Promise.all(h);for(let r=0,a=d.length;r<a;r++){const a=t.subobjects[r],i=d[r];if(null===i)continue;if(i.isGroup){const r=i;a.matrix.decompose(r.position,r.quaternion,r.scale),r.userData.startingConstructionStep=a.startingConstructionStep,r.name=a.fileName,e.applyMaterialsToMesh(r,a.colorCode,t.materials),u.add(r);continue}i.group.children.length&&u.add(i.group);const s=t.lineSegments,c=t.conditionalSegments,h=t.faces,g=i.lineSegments,m=i.conditionalSegments,f=i.faces,C=a.matrix,w=a.inverted,M=C.determinant()<0,b=a.colorCode,y=b===n?o:b;for(let e=0,r=g.length;e<r;e++){const r=g[e],a=r.vertices;a[0].applyMatrix4(C),a[1].applyMatrix4(C),r.colorCode=r.colorCode===o?y:r.colorCode,r.material=r.material||p(r.colorCode,r.colorCode,t.materials,!0),s.push(r)}for(let e=0,r=m.length;e<r;e++){const r=m[e],a=r.vertices,n=r.controlPoints;a[0].applyMatrix4(C),a[1].applyMatrix4(C),n[0].applyMatrix4(C),n[1].applyMatrix4(C),r.colorCode=r.colorCode===o?y:r.colorCode,r.material=r.material||p(r.colorCode,r.colorCode,t.materials,!0),c.push(r)}for(let e=0,r=f.length;e<r;e++){const r=f[e],a=r.vertices;for(let t=0,e=a.length;t<e;t++)a[t].applyMatrix4(C);r.colorCode=r.colorCode===n?b:r.colorCode,r.material=r.material||p(r.colorCode,b,t.materials,!1),l.add(r.colorCode),M!==w&&a.reverse(),h.push(r)}t.totalFaces+=i.totalFaces}return i&&e.applyMaterialsToMesh(u,i.colorCode,t.materials),t};for(let e=0,r=t.faces;e<r;e++)l.add(t.faces[e].colorCode);if(await c(t),e.smoothNormals){const e=l.size>1;!function(t){for(let e=0,r=t.length;e<r;e++){const r=t[e],n=r.vertices,o=n[0],l=n[1],c=n[2];i.subVectors(l,o),s.subVectors(c,l),r.faceNormal=(new a.Vector3).crossVectors(i,s).normalize()}}(t.faces),function(t,e,r=!1){const n=100*(1+1e-10);function o(t){return`${~~(t.x*n)},${~~(t.y*n)},${~~(t.z*n)}`}function i(t,e){return`${o(t)}_${o(e)}`}function s(t,e,r){r.direction.subVectors(e,t).normalize();const a=t.dot(r.direction);return r.origin.copy(t).addScaledVector(r.direction,-a),r}function l(t){return i(t.origin,t.direction)}const c=new Set,u=new Map,d={},g=[];for(let t=0,n=e.length;t<n;t++){const n=e[t].vertices,o=n[0],h=n[1];if(c.add(i(o,h)),c.add(i(h,o)),r){const t=s(o,h,new a.Ray),e=l(t);if(!u.has(e)){s(h,o,t);const r=l(t),a={ray:t,distances:[]};u.set(e,a),u.set(r,a)}const r=u.get(e);let n=r.ray.direction.dot(o),i=r.ray.direction.dot(h);n>i&&([n,i]=[i,n]),r.distances.push(n,i)}}for(let e=0,a=t.length;e<a;e++){const a=t[e],n=a.vertices,o=n.length;for(let t=0;t<o;t++){const e=t,g=(t+1)%o,p=n[e],m=n[g],f=i(p,m);if(c.has(f))continue;if(r){s(p,m,h);const t=l(h);if(u.has(t)){const e=u.get(t),{ray:r,distances:a}=e;let n=r.direction.dot(p),o=r.direction.dot(m);n>o&&([n,o]=[o,n]);let i=!1;for(let t=0,e=a.length;t<e;t+=2)if(n>=a[t]&&o<=a[t+1]){i=!0;break}if(i)continue}}const C={index:e,tri:a};d[f]=C}}for(;;){let t=null;for(const e in d){t=d[e];break}if(null===t)break;const e=[t];for(;e.length>0;){const t=e.pop().tri,r=t.vertices,n=t.normals,o=t.faceNormal,s=r.length;for(let l=0;l<s;l++){const c=l,h=(l+1)%s,u=r[c],p=r[h];delete d[i(u,p)];const m=i(p,u),f=d[m];if(f){const r=f.tri,i=f.index,s=r.normals,l=s.length,u=r.faceNormal;if(Math.abs(r.faceNormal.dot(t.faceNormal))<.25)continue;m in d&&(e.push(f),delete d[m]);const p=(i+1)%l;n[c]&&s[p]&&n[c]!==s[p]&&(s[p].norm.add(n[c].norm),n[c].norm=s[p].norm);let C=n[c]||s[p];null===C&&(C={norm:new a.Vector3},g.push(C.norm)),null===n[c]&&(n[c]=C,C.norm.add(o)),null===s[p]&&(s[p]=C,C.norm.add(u)),n[h]&&s[i]&&n[h]!==s[i]&&(s[i].norm.add(n[h].norm),n[h].norm=s[i].norm);let w=n[h]||s[i];null===w&&(w={norm:new a.Vector3},g.push(w.norm)),null===n[h]&&(n[h]=w,w.norm.add(o)),null===s[i]&&(s[i]=w,w.norm.add(u))}}}}for(let t=0,e=g.length;t<e;t++)g[t].normalize()}(t.faces,t.lineSegments,e)}const u=t.group;return t.faces.length>0&&u.add(C(t.faces,3,!1,t.totalFaces)),t.lineSegments.length>0&&u.add(C(t.lineSegments,2)),t.conditionalSegments.length>0&&u.add(C(t.conditionalSegments,2,!0)),u}hasCachedModel(t){return null!==t&&t.toLowerCase()in this._cache}async getCachedModel(t){if(null!==t&&this.hasCachedModel(t)){const e=t.toLowerCase();return(await this._cache[e]).clone()}return null}async loadModel(t){const e=this.parseCache,r=t.toLowerCase();if(this.hasCachedModel(t))return this.getCachedModel(t);{await e.ensureDataLoaded(t);const a=e.getData(t),n=this.processIntoMesh(a);return this.hasCachedModel(t)?this.getCachedModel(t):(u(a.type)&&(this._cache[r]=n),(await n).clone())}}async parseModel(t){const e=this.parseCache.parse(t);return u(e.type)&&this.hasCachedModel(e.fileName)?this.getCachedModel(e.fileName):this.processIntoMesh(e)}}function f(t,e){return t.colorCode===e.colorCode?0:t.colorCode<e.colorCode?-1:1}function C(t,e,r=!1,n=null){t.sort(f),null===n&&(n=t.length);const o=new Float32Array(e*n*3),l=3===e?new Float32Array(e*n*3):null,h=[],u=new Array(6),d=new a.BufferGeometry;let g=null,p=0,m=0,C=0;for(let n=0,c=t.length;n<c;n++){const c=t[n];let f=c.vertices;4===f.length&&(u[0]=f[0],u[1]=f[1],u[2]=f[2],u[3]=f[0],u[4]=f[2],u[5]=f[3],f=u);for(let t=0,e=f.length;t<e;t++){const e=f[t],r=C+3*t;o[r+0]=e.x,o[r+1]=e.y,o[r+2]=e.z}if(3===e){if(!c.faceNormal){const t=f[0],e=f[1],r=f[2];i.subVectors(e,t),s.subVectors(r,e),c.faceNormal=(new a.Vector3).crossVectors(i,s).normalize()}let t=c.normals;4===t.length&&(u[0]=t[0],u[1]=t[1],u[2]=t[2],u[3]=t[0],u[4]=t[2],u[5]=t[3],t=u);for(let e=0,r=t.length;e<r;e++){let r=c.faceNormal;t[e]&&(r=t[e].norm);const a=C+3*e;l[a+0]=r.x,l[a+1]=r.y,l[a+2]=r.z}}if(g!==c.colorCode){null!==g&&d.addGroup(p,m,h.length-1);const t=c.material;null!==t?3===e?h.push(t):2===e&&(r?h.push(t.userData.edgeMaterial.userData.conditionalEdgeMaterial):h.push(t.userData.edgeMaterial)):h.push(c.colorCode),g=c.colorCode,p=C/3,m=f.length}else m+=f.length;C+=3*f.length}m>0&&d.addGroup(p,1/0,h.length-1),d.setAttribute("position",new a.BufferAttribute(o,3)),null!==l&&d.setAttribute("normal",new a.BufferAttribute(l,3));let w=null;if(2===e?w=r?new c(d,1===h.length?h[0]:h):new a.LineSegments(d,1===h.length?h[0]:h):3===e&&(w=new a.Mesh(d,1===h.length?h[0]:h)),r){w.isConditionalLine=!0;const e=new Float32Array(3*t.length*2),r=new Float32Array(3*t.length*2),n=new Float32Array(3*t.length*2);for(let a=0,o=t.length;a<o;a++){const o=t[a],i=o.vertices,s=o.controlPoints,l=s[0],c=s[1],h=i[0],u=i[1],d=3*a*2;e[d+0]=l.x,e[d+1]=l.y,e[d+2]=l.z,e[d+3]=l.x,e[d+4]=l.y,e[d+5]=l.z,r[d+0]=c.x,r[d+1]=c.y,r[d+2]=c.z,r[d+3]=c.x,r[d+4]=c.y,r[d+5]=c.z,n[d+0]=u.x-h.x,n[d+1]=u.y-h.y,n[d+2]=u.z-h.z,n[d+3]=u.x-h.x,n[d+4]=u.y-h.y,n[d+5]=u.z-h.z}d.setAttribute("control0",new a.BufferAttribute(e,3,!1)),d.setAttribute("control1",new a.BufferAttribute(r,3,!1)),d.setAttribute("direction",new a.BufferAttribute(n,3,!1))}return w}class w extends a.Loader{constructor(t){super(t),this.materials=[],this.materialLibrary={},this.partsCache=new m(this),this.fileMap={},this.setMaterials([]),this.smoothNormals=!0,this.partsLibraryPath=""}setPartsLibraryPath(t){return this.partsLibraryPath=t,this}async preloadMaterials(t){const e=new a.FileLoader(this.manager);e.setPath(this.path),e.setRequestHeader(this.requestHeader),e.setWithCredentials(this.withCredentials);const r=/^0 !COLOUR/,n=(await e.loadAsync(t)).split(/[\n\r]/g),o=[];for(let t=0,e=n.length;t<e;t++){const e=n[t];if(r.test(e)){const t=e.replace(r,""),a=this.parseColorMetaDirective(new d(t));o.push(a)}}this.setMaterials(o)}load(t,e,r,o){const i=new a.FileLoader(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(t,(t=>{this.partsCache.parseModel(t,this.materialLibrary).then((t=>{this.applyMaterialsToMesh(t,n,this.materialLibrary,!0),this.computeConstructionSteps(t),e(t)})).catch(o)}),r,o)}parse(t,e){this.partsCache.parseModel(t,this.materialLibrary).then((t=>{this.computeConstructionSteps(t),e(t)}))}setMaterials(t){this.materialLibrary={},this.materials=[];for(let e=0,r=t.length;e<r;e++)this.addMaterial(t[e]);return this.addMaterial(this.parseColorMetaDirective(new d("Main_Colour CODE 16 VALUE #FF8080 EDGE #333333"))),this.addMaterial(this.parseColorMetaDirective(new d("Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333"))),this}setFileMap(t){return this.fileMap=t,this}addMaterial(t){const e=this.materialLibrary;return e[t.userData.code]||(this.materials.push(t),e[t.userData.code]=t),this}getMaterial(t){if(t.startsWith("0x2")){const e=t.substring(3);return this.parseColorMetaDirective(new d("Direct_Color_"+e+" CODE -1 VALUE #"+e+" EDGE #"+e))}return this.materialLibrary[t]||null}applyMaterialsToMesh(t,e,r,a=!1){const i=this,s=e===n;function l(t,l){if(s&&!(l in r)&&!a)return l;const c=t.isLineSegments||t.isConditionalLine;(!c&&l===n||c&&l===o)&&(l=e);let h=null;if(l in r)h=r[l];else{if(!a)return l;if(h=i.getMaterial(l),null===h)throw new Error(`LDrawLoader: Material properties for code ${l} not available.`)}return t.isLineSegments&&(h=h.userData.edgeMaterial,t.isConditionalLine&&(h=h.userData.conditionalEdgeMaterial)),h}t.traverse((t=>{if(t.isMesh||t.isLineSegments)if(Array.isArray(t.material))for(let e=0,r=t.material.length;e<r;e++)t.material[e].isMaterial||(t.material[e]=l(t,t.material[e]));else t.material.isMaterial||(t.material=l(t,t.material))}))}getMainMaterial(){return this.getMaterial(n)}getMainEdgeMaterial(){const t=this.getMainMaterial();return t&&t.userData?t.userData.edgeMaterial:null}parseColorMetaDirective(t){let e=null,r=16711935,n=16711935,o=1,i=!1,s=0,c=0,h=null;const u=t.getToken();if(!u)throw new Error('LDrawLoader: Material name was expected after "!COLOUR tag'+t.getLineNumberString()+".");let g=null;for(;g=t.getToken(),g;)switch(g.toUpperCase()){case"CODE":e=t.getToken();break;case"VALUE":if(r=t.getToken(),r.startsWith("0x"))r="#"+r.substring(2);else if(!r.startsWith("#"))throw new Error("LDrawLoader: Invalid color while parsing material"+t.getLineNumberString()+".");break;case"EDGE":if(n=t.getToken(),n.startsWith("0x"))n="#"+n.substring(2);else if(!n.startsWith("#")){if(h=this.getMaterial(n),!h)throw new Error("LDrawLoader: Invalid edge color while parsing material"+t.getLineNumberString()+".");h=h.userData.edgeMaterial}break;case"ALPHA":if(o=parseInt(t.getToken()),isNaN(o))throw new Error("LDrawLoader: Invalid alpha value in material definition"+t.getLineNumberString()+".");o=Math.max(0,Math.min(1,o/255)),o<1&&(i=!0);break;case"LUMINANCE":if(s=parseInt(t.getToken()),isNaN(s))throw new Error("LDrawLoader: Invalid luminance value in material definition"+d.getLineNumberString()+".");s=Math.max(0,Math.min(1,s/255));break;case"CHROME":c=1;break;case"PEARLESCENT":c=2;break;case"RUBBER":c=3;break;case"MATTE_METALLIC":c=4;break;case"METAL":c=5;break;case"MATERIAL":t.setToEnd();break;default:throw new Error('LDrawLoader: Unknown token "'+g+'" while parsing material'+t.getLineNumberString()+".")}let p=null;switch(c){case 0:p=new a.MeshStandardMaterial({color:r,roughness:.3,metalness:0});break;case 2:p=new a.MeshStandardMaterial({color:r,roughness:.3,metalness:.25});break;case 1:p=new a.MeshStandardMaterial({color:r,roughness:0,metalness:1});break;case 3:p=new a.MeshStandardMaterial({color:r,roughness:.9,metalness:0});break;case 4:p=new a.MeshStandardMaterial({color:r,roughness:.8,metalness:.4});break;case 5:p=new a.MeshStandardMaterial({color:r,roughness:.2,metalness:.85})}return p.transparent=i,p.premultipliedAlpha=!0,p.opacity=o,p.depthWrite=!i,p.color.convertSRGBToLinear(),p.polygonOffset=!0,p.polygonOffsetFactor=1,0!==s&&p.emissive.set(p.color).multiplyScalar(s),h||(h=new a.LineBasicMaterial({color:n,transparent:i,opacity:o,depthWrite:!i}),h.userData.code=e,h.name=u+" - Edge",h.color.convertSRGBToLinear(),h.userData.conditionalEdgeMaterial=new l({fog:!0,transparent:i,depthWrite:!i,color:n,opacity:o}),h.userData.conditionalEdgeMaterial.color.convertSRGBToLinear()),p.userData.code=e,p.name=u,p.userData.edgeMaterial=h,this.addMaterial(p),p}computeConstructionSteps(t){let e=0;t.traverse((t=>{t.isGroup&&(t.userData.startingConstructionStep&&e++,t.userData.constructionStep=e)})),t.userData.numConstructionSteps=e+1}}}}]);